
/*

-----------------------------------------------------------------------------------------				-----------------------------------------------------------------------------
|							системный вызов для СОЗДАНИЯ СОКЕТА							|				|					перевод сокета в НЕБЛОКИРУЮЩИЙ РЕЖИМ					|
|				int sockfd = socket(int family, int type, int protocol);				|				|---------------------------------------------------------------------------|
|---------------------------------------------------------------------------------------|				|		int flags = fcntl(sockfd, F_GETFL);									|
|		family (семейство адресации):													|				|		fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);							|
|			AF_INET - взаимодействие по сети											|				|---------------------------------------------------------------------------|
|				протоколы TCP/IP, адрес сокета ip-адрес/порт)							|				|	требуется перевести слушающий и клиентские сокеты в неблакирующий режим	|
|		type (тип взаимодействия контента):												|				|	для того чтобы вызовы read(), write() и accept() возвращали управление	|
|			SOCK_STREAM - потоковое взаимодействие										|				-----------------------------------------------------------------------------
|			SOCK_DGRAM - дейтаграммное взаимодействие									|
|		protocol:																		|		-----------------------------------------------------------------------------------------
|			0 - определяется первыми 2-мя параметрами									|		|					системный вызов для обхода TIME_WAIT ( ЗАЛИПАНИЕ СОКЕТА )			|
|			IPPROTO_TCP - для TCP														|		|		int opt = 1;																	|
|			IPPROTO_UDP - для UDP														|		|		setsockopt(int sockfd, int level, int optname, const void *optval, int optlen);	|
|		sockfd - дескриптор сокета (-1 при ошибке)										|		|---------------------------------------------------------------------------------------|
--------------------------------------------|--------------------------------------------		|			level - уровень(слой) протокола												|
											|											 		|				SOL_SOCKET - опции для уровеня сокетов									|
											|---------------------------------------------------|			optname - имя устанавливаемой опции											|
											|											 		|				SO_REUSEADDR - разрешить повторное использование локального адреса		|
--------------------------------------------|--------------------------------------------		|			optval - значение опции														|
|						системный вызов для ПРИВЯЗКИ СОКЕТУ АДРЕСА						|		|				opt - 1 для опции SO_REUSEADDR											|
|				int bind(int sockfd, (struct sockaddr*)&addr, int addrlen);				|		|			optlen - siziof(opt)														|
|---------------------------------------------------------------------------------------|		-----------------------------------------------------------------------------------------
|		*addr - указатель на структуру типа struct sockaddr_in, содержащую адрес		|
|			addr.sin_family - семейство адресации (AF_INET)								|		---------------------------------------------------------------------------------------------
|			addr.sin_port - номер порта в сетевом порядке байтов						|		|							систмный вызов для ВЫБОРА СОБЫТИЯ								|
|			addr.sin_addr - структура содержащая адрес (WTF!?)							|		|	int select(int n, fd_set *rfds, fd_set *wfds, fd_set *exfds, struct timeval *timeout);	|
|				sin_addr.s_addr - ip-адрес в сетевом порядке байтов						|		|-------------------------------------------------------------------------------------------|	FD_ZERO(fd_set *set); очистить мн-во
|					INADDR_ANY == 0 (0.0.0.0)											|		|	rfds, wfds, exfds - мн-ва дескрипторов, для которых нас интересует чтение, запись или	|	FD_SET(int fd, fd_set *set); - добавить дескриптор в мн-во
|		addrlen - размер структуры sockaddr_in											|		|		исключительная ситуация соответственно												|	FD_CLR(int fd, fd_set *set); - убрать дескриптор из мт-ва
|		return -1 при ошибке															|		|	n - кол-во эленетов в этих мн-вах														|	FD_ISSET(int fd, fd_set *set); - входит ли дескриптор в мн-во ?
--------------------------------------------|--------------------------------------------		|		n = максимальный номер дескриптора для обработки события + 1						|
											|													|	timeout - промежуток времени, после которого вернуть управление							|
											|													---------------------------------------------------------------------------------------------
--------------------------------------------|--------------------------------------------
|				системный вызоа для ПЕРЕВОДА СОКЕТА В СЛУШАЮЩИЙ РЕЖИМ					|
|						int listen(int sockfd, int qlen);								|
|---------------------------------------------------------------------------------------|
|		qlen - задаёт размер очереди запросов на соединение								|
--------------------------------------------|--------------------------------------------
											|
											|
--------------------------------------------|--------------------------------------------
|						системный вызов для ПРИНЯТИЯ СОЕДИНЕНИЯ							|
|	int new_sockfd = accept(int sockfd, (struct sockaddr*)&addr, socklen_t *addrlen);	|
|---------------------------------------------------------------------------------------|
|		addr - указатель на структуру типа struct sockaddr_in для записи адреса клиента	|
|		addrlen - будет содержать кол-во байт записанных в структуру addr				|
|			перед вызовом accept, в addrlen следует записать начальный размер структуры	|
|				socklen_t addrlen = sizeof(addr)										|
|		new_sockfd - сокет для обслуживания созданного соединения (-1 при ошибке)		|
-----------------------------------------------------------------------------------------

*/

#include "../includes/WebServ.hpp"

int	main(int ac, char **av)
{
	if (ac > 2)
		std::cerr << "too many args" << std::endl;
	else
	{
		signal(SIGPIPE, SIG_IGN); /*	сигнал записи в закрытое соединение	*/
		std::string conf = (ac == 1) ? "configs/default.conf" : av[1];
		try
		{
			WebServ		WebServ(conf);
			WebServ.mainCycly();
		}
		catch (const std::string &error)
		{
			std::cerr << error << std::endl;
			return 1;
		}
	}
	return 0;
}
